package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
    boolean errorDetected = false;
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
      errorDetected = true;
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax fault ", cur_token);
        errorDetected = true;
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error, parsing couldn't be continued", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	 errorDetected = true;
    	if (info instanceof Symbol)
            msg.append (" on the line ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, PRINT, RETURN, PLUS, EQUAL, COMMA, SEMI, LPAREN, RPAREN, LBRACE, RBRACE;
terminal VOID, CONST, IF, ELSE, FOR, WHILE, INC, DEC, NEW, LE, GE, LEQ, GEQ, ISEQUAL, NEQUAL, MUL, DIV, GOTO, READ;
terminal SWITCH, AND, OR, CASE, MODUL, MINUS, LBRACKET, RBRACKET, COL, CLASS, EXTENDS, DOT, CONTINUE, BREAK;

terminal RECORD, DO;

terminal String IDENT;
terminal Character CHAR;
terminal Integer BOOL;
terminal Integer NUMBER;

nonterminal DoWhileHeader, DoWhileEnd;
nonterminal Mdecl;

nonterminal ConstDecl, MethodDecl, LineConstDecl, SimpleConstDecl;

nonterminal VarDecl, SingleVarDecl, LineVarDecl, ArrayOperator, MultipleVarDecl, GlobalVarDecl, GlobalLineVarDecl;

nonterminal ClassDecl, ClassAllMethodDecl, ExtendsOper;

nonterminal ConstructorDecl;

nonterminal ClassMethodDecl, MultipleFormParams, FormParams, MethodReturnType, MethodSingleParemeter;

nonterminal RecordStructure;

nonterminal Statement, SingleStatement, Statements, StatementsWithoutBraces;

nonterminal ElseStatement, Condition, CondTerm, CondFact;

nonterminal MultipleDesignator, ListStatement, DesignatorStatement, DesignatorPostOperation;

nonterminal ActPars;

nonterminal Assignop, Relop, Addop, Mulop;

nonterminal Label, MultipleNumConst;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, SingleMethodDecl, SingleMethodName, Designator, DesignatorFactor;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Consts, Expr, AddExpr, Term, Factor, NewTypeFactor;
precedence left ELSE;

Program ::= (ProgramWithMethods) PROG ProgName Mdecl LBRACE ClassMethodDecl RBRACE
			|
			(ProgramWithoutMethods) PROG ProgName Mdecl LBRACE RBRACE;

ProgName ::= (ProgName) IDENT:progName;

Mdecl ::= (ConstantDeclaration) Mdecl ConstDecl 
			|
			(GlobalVariableDeclaration) Mdecl GlobalVarDecl 
			|
			(ClassDecleration) Mdecl ClassDecl
			|
			(RecordDeclaration) Mdecl RecordStructure
			|
			(EmptyDeclaration) ;



ConstDecl ::= (ConstantDecl)CONST Type SimpleConstDecl LineConstDecl;
SimpleConstDecl ::= (SimpleConstDecl) IDENT:varName EQUAL Consts:constValue;
LineConstDecl ::= (LineConstantDecl) COMMA SimpleConstDecl LineConstDecl  
				| 
			   SEMI; 


GlobalVarDecl ::= (GlobalVariableDecl)SingleVarDecl GlobalLineVarDecl
			|
			(ErrorVarDecl)error GlobalLineVarDecl;
VarDecl ::= (VariableDecl)SingleVarDecl LineVarDecl;
SingleVarDecl ::= (SingleVariableDecl) Type IDENT:varName ArrayOperator;
GlobalLineVarDecl ::= (GlobalLineVariableDecl) COMMA IDENT ArrayOperator GlobalLineVarDecl
			|
			(EmptyGlobalLineVariableDecl)SEMI
			| 
			(ErrorLineVariableDecl) COMMA error GlobalLineVarDecl;
LineVarDecl ::= (LineVariableDecl) COMMA IDENT ArrayOperator LineVarDecl
			| 
			(EmptyLineVariableDecl)SEMI;
ArrayOperator ::= (ArrayOperator)LBRACKET RBRACKET 
					| 
					(EmptyArrayOperator) ;
MultipleVarDecl ::= (MultipleVariableDecl)MultipleVarDecl VarDecl
					|
					(EmptyVariableDecl) ;


ClassDecl ::= CLASS IDENT ExtendsOper LBRACE MultipleVarDecl LBRACE ClassAllMethodDecl RBRACE RBRACE;
ClassAllMethodDecl ::= (ClassAllMethodDeclaration) ConstructorDecl ClassMethodDecl
							|
							(SingleConstructorDeclaration) ConstructorDecl
							|
							(MethodDeclarationOnly) ClassMethodDecl 
							|
							(EmptyClassAllMethodDeclaration) 
							;
ExtendsOper ::= (Extends)EXTENDS IDENT 
				|
				(EmptyExtends);



ConstructorDecl ::= (ConstructorDeclaration) IDENT LPAREN RPAREN MultipleVarDecl LBRACE ListStatement RBRACE;				
				
				
				
				
SingleMethodDecl ::= (SingleMethodDeclaration) SingleMethodName LPAREN FormParams RPAREN MultipleVarDecl LBRACE ListStatement RBRACE;
SingleMethodName ::= (SingleMethodName)MethodReturnType IDENT:methodName;
ClassMethodDecl ::= (MultipleMethodDeclaration) ClassMethodDecl  SingleMethodDecl
					|(OneMethodDeclaration)SingleMethodDecl; 
MethodSingleParemeter ::= (MethodSingleParemeter) Type IDENT:varName ArrayOperator;
MultipleFormParams ::= (MultipleFormalParameters) MultipleFormParams COMMA MethodSingleParemeter
						|
						(OnlyFormalParameter)MethodSingleParemeter;
FormParams ::= (FormalParameters) MultipleFormParams
				|
				(NoFormalParameters);
MethodReturnType ::= (ReturnType)Type
					|
					(VoidType)VOID;		
ListStatement ::= (MultipleStatement) ListStatement Statement
					|
				  (NoStatement) ;
SingleStatement ::=	(IfElseStatement)IF LPAREN Condition RPAREN Statement ElseStatement
					|
					(DesignStatement)DesignatorStatement SEMI
					|
					(BreakStatement) BREAK SEMI
					|
					(ContinueStatement) CONTINUE SEMI
					|
					(GotoStatement) GOTO Label SEMI
					|
					(ReturnStatementNoExpr) RETURN SEMI
					|
					(ReturnStatementExpr) RETURN Expr SEMI
					|
					(DoWhileStatement) DoWhileHeader Statement DoWhileEnd WHILE LPAREN Condition RPAREN SEMI
					|
					(ReadStatement) READ LPAREN Designator RPAREN SEMI
					|
					(PrintStatement) PRINT LPAREN Expr:printExpression MultipleNumConst RPAREN SEMI;
DoWhileHeader ::= (DoWhileHeader) DO;
DoWhileEnd ::= (DoWhileEnd) WHILE;
ElseStatement ::= (NoElseStatement)
				|
				  (HaveElseStatement) ELSE Statement; 
StatementsWithoutBraces ::= (OneStatement)Statement
							|
			   				(MoreThenOneStatement)StatementsWithoutBraces Statement;
Statements ::= (MultipleStatements)LBRACE StatementsWithoutBraces RBRACE
				|
				(NoStatements)LBRACE RBRACE;
Statement ::= (ColStatementRed)Label COL SingleStatement
			|
			 (OneStatementRed)SingleStatement
			|
			(StatementsRed)Statements;
Condition ::= (SingleIfCondition) CondTerm
			|
			   (MultipleIfCondition) CondTerm OR Condition;
CondTerm ::= (SingleCondTerm) CondFact
			|
			(MultipleCondTerm)CondFact AND CondTerm;
CondFact ::= (SingleCondFact)Expr 
			|
			 (MultipleCondFact)Expr Relop Expr;
AddExpr ::=(OneAddExpr)Term
			|
			(MultipleAddExpr)AddExpr Addop Term;
Expr ::= (MinusExpr)MINUS AddExpr
		|
		(AddExptOnly)AddExpr;
Term ::= (OneTerm)Factor 
		|
		 (MultipleTerm)Term Mulop Factor;
Factor ::= (CharConst) CHAR
			|
			(NumConst) NUMBER
			|
			(BoolConst) BOOL
			|
			(ParenExpresion) LPAREN Expr RPAREN
			|
			(NewTypeFactorExpresion) NewTypeFactor
			|
			(DesignatorFactorExpresion) DesignatorFactor;
DesignatorFactor ::= (DesignatorConstr) Designator LPAREN RPAREN
					|
					 (DesignatorConstrPar) Designator LPAREN ActPars RPAREN
					|
					 (DesignatorOnly) Designator; 
NewTypeFactor ::= (NewTypeNoArray)NEW Type
				 |
				  (NewTypeArray) NEW Type LBRACKET Expr RBRACKET;
				  
Designator ::= (DesignatorFullExpresion) IDENT:designatorName MultipleDesignator;
MultipleDesignator ::= (EmptyMultipleDesignator) 
						|
						(DesignatorArray)MultipleDesignator LBRACKET Expr RBRACKET
						|
						(DesignatorStructure)MultipleDesignator DOT IDENT;
ActPars ::= (OneActPars)Expr
			|
			(MultipleActPars)ActPars COMMA Expr;
DesignatorStatement ::= (DesignatorStat)Designator DesignatorPostOperation;
DesignatorPostOperation ::= (AssignDesignatorOp)Assignop Expr
							|
							(ParActParsDesignatorOp) LPAREN ActPars RPAREN
							|
							(ParDesignatorOp) LPAREN RPAREN
							|
							(DesignatorIncrement)INC
							|
							(DesignatorDecrement)DEC; 
Assignop ::= (AssignOperation)EQUAL;
Relop ::= (IsEqualOp)ISEQUAL | (NotEqualOp)NEQUAL | (GreaterOp)GE |(GreaterEqualOp) GEQ |(LessOp) LE |(LessEqualOp) LEQ;
Addop ::= (PlusOp)PLUS
		 |
		 (MinusOp)MINUS;
Mulop ::= (MulOperation)MUL
		|
		(DivOperation)DIV
		|
		(ModulOperation)MODUL;		
		
		
			
RecordStructure ::= (RecordStruct)RECORD IDENT LBRACE MultipleVarDecl RBRACE;


MultipleNumConst ::= (NumConsts) MultipleNumConst COMMA NUMBER
					|
					(NoNumConsts);
Consts ::= (BooleanConstant)BOOL:value
			| 
			(NumberConstant)NUMBER:value
			| 
			(CharacterConstant)CHAR:value;
Type ::= (Type)IDENT:typeName;
Label ::= (LabelIdent)IDENT;